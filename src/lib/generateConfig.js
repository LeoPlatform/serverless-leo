/* eslint-disable space-before-function-paren */
/* eslint-disable no-template-curly-in-string */
const fs = require('fs')
const path = require('path')

let ts
try {
  ts = require('typescript')
} catch (e) {
  // No Typescript
}

const isTS = ts != null

function generateConfig(filePath) {
  let ext = isTS ? '.ts' : '.js'
  let dTSFilePath = filePath.replace(/\..*\.json$/, '.d.ts')
  let configOutputPath = filePath.replace(/\..*\.json$/, ext)
  let projectConfigTxt = fs.readFileSync(filePath).toString()
  if (!projectConfigTxt) {
    return
  }
  let projectConfig = JSON.parse(projectConfigTxt)
  let buildConfig = projectConfig.configBuilderOptions || {}
  delete projectConfig.configBuilderOptions

  let interfaces = {}
  if (isTS && fs.existsSync(dTSFilePath)) {
    let src = ts.createSourceFile('blah.ts', fs.readFileSync(dTSFilePath).toString(), ts.ScriptTarget.ES2022)

    src.forEachChild(child => {
      if (child.kind === ts.SyntaxKind.InterfaceDeclaration) {
        let o = build(child, projectConfig, [])

        let intf = child
        let flat = {}
        flattenVariables(o, flat, '.', '')
        interfaces[intf.name.escapedText] = flat
      }
    })
  }

  let interfaceName = Object.keys(interfaces)[0]
  let configInterface = interfaces[interfaceName] || {}
  function expandConfig(projectConfig, path) {
    let o = {}
    Object.entries(projectConfig).forEach(([key, value]) => {
      let fieldPath = path.concat(key)
      if (typeof value === 'string' && value.match(/^.+?::/)) {
        let [service, key, type, opts] = value.split('::')
        value = {
          is_config_reference: true,
          service,
          key,
          type: (configInterface[fieldPath.join('.')] || {}).type || type || 'dynamic',
          options: opts && inferTypes((opts).split(';').reduce((all, one) => {
            let [key, value] = one.split('=')
            if (key !== '') {
              all[key] = value == null ? true : value
            }
            return all
          }, {}))
        }
      }

      if (
        value != null && typeof value === 'object' &&
        (value.service == null || value.key == null || value.type == null)
      ) {
        value = expandConfig(value, fieldPath)
      }
      o[key] = value
    })

    return o
  }

  let eConfig = expandConfig(projectConfig, [])

  let interfaceDef = ''

  let all = (projectConfigTxt.match(/^(\t| )/gm) || []).reduce((s, o) => {
    if (o === '\t') {
      s.tabs++
    } else {
      s.spaces++
    }
    return s
  }, {
    tabs: 0,
    spaces: 0
  })
  let spaces = '\t'
  if (all.spaces > all.tabs) {
    spaces = (projectConfigTxt.match(/^( +)/gm) || ['  '])[0]
  }
  if (interfaceName == null) {
    interfaceName = toProperCase(path.basename(configOutputPath).replace(/\.[tj]s$/, ''))
  }

  let spacesLength = spaces.length

  let imports = new Set()
  let knownTypes = {
    'string': 'string',
    'number': 'number',
    'float': 'number',
    'integer': 'number',
    'int': 'number',
    'dynamic': 'dynamic',
    'unknown': 'unknown'
  }
  function getType(field, depth = '') {
    if (field != null && typeof field === 'object') {
      if (field.service != null && field.key != null && field.type != null) {
        let t = field.type === 'dynamic' ? 'unknown' : field.type

        if (!knownTypes[t]) {
          imports.add(t)
        } else {
          t = knownTypes[t]
        }
        return t
      } else {
        let nextDepth = depth += spaces
        let r = Object.entries(field).map(([key, value]) => {
          return `${nextDepth}${key}: ${getType(value, nextDepth)};`
        }).join('\n')
        return `{\n${r}\n${depth.substring(0, depth.length - spacesLength)}}`
      }
    } else {
      return typeof field
    }
  }

  interfaceDef = resolveKeywords(
    '${imports}export interface ${interfaceName} ${value}\n',
    {
      interfaceName: interfaceName,
      value: getType(eConfig),
      imports: imports.size ? `import { ${Array.from(imports).join(', ')} } from "types";\n\n` : ''
    }, { spaces: spaces })

  let template = [
    '/* Generated by serverless-leo */',
    isTS
      ? 'import { ConfigurationBuilder } from "leo-sdk/lib/configuration-builder";'
      : 'const { ConfigurationBuilder } = require("leo-sdk/lib/configuration-builder");',
    isTS ? '${interfaceDef}' : '',
    // (isTS ? 'export default' : 'module.exports = ') + ' new ConfigurationBuilder' + (isTS ? '<${interfaceName}>' : '') + '(${config}).build(${buildConfig});'
    (isTS ? 'export default' : 'module.exports = ') + ' new ConfigurationBuilder' + (isTS ? '<${interfaceName}>' : '') + '(process.env.RSF_CONFIG).build(${buildConfig});'
  ].join('\n')

  let fileBody = resolveKeywords(template, {
    interfaceDef: interfaceDef,
    interfaceName: interfaceName,
    config: JSON.stringify(eConfig, (_key, value) => {
      if (value != null && typeof value === 'object' && value.service && value.key && value.type) {
        return `__CLASS_START__new ${toProperCase(value.service)}Resource("${value.key}", "${value.type}"${value.options != null ? (', ' + JSON.stringify(value.options)) : ''}),__CLASS_END__`
      }
      return value
    }, spaces).replace(/"__CLASS_START__(.*?)__CLASS_END__",?/g, (_a, b) => {
      return b.replace(/\\"/g, '"')
    }),
    buildConfig: buildConfig
  }, {
    spaces: spaces
  })

  fs.writeFileSync(configOutputPath, fileBody)

  if (!isTS) {
    fs.writeFileSync(dTSFilePath, [
      `${interfaceDef}`,
      `declare const configuration: ${interfaceName};`,
      `export default configuration;`
    ].join('\n'))
  }

  return eConfig
}

function build(child, projectConfig, path) {
  let o = {};

  (child.members || []).forEach((field) => {
    let type = ts.SyntaxKind[field.type.kind].replace(/Keyword/, '').toLowerCase()
    let name = field.name.escapedText
    let fieldPath = path.concat(name)
    let value = { _isLeaf: true, type, name, path: fieldPath.join('.'), projectConfigValue: projectConfig[name] }

    if (field.type.members != null) {
      value = build(field.type, projectConfig[name], fieldPath)
    }

    o[name] = value
  })

  return o
}

function flattenVariables(obj, out, separator, prefix) {
  prefix = prefix || ''
  separator = separator || ':'
  Object.keys(obj).forEach((k) => {
    var v = obj[k]
    if (typeof v === 'object' && !(Array.isArray(v)) && v !== null && !v._isLeaf) {
      flattenVariables(v, out, separator, prefix + k + separator)
    } else {
      out[prefix + k] = v
    }
  })
}

function toProperCase(text) {
  return text.replace(/[^a-zA-Z0-9]+/g, '_').replace(/(^\w|_\w)/g, function (txt) {
    return txt.charAt(txt.length === 1 ? 0 : 1).toUpperCase()
  })
}

function getDataSafe(data = {}, path = '') {
  const pathArray = path.split('.').filter(a => a !== '')
  if (pathArray.length === 0) {
    return data
  }
  const lastField = pathArray.pop()
  return pathArray.reduce((parent, field) => parent[field] || {}, data)[lastField]
}

function resolveKeywords(template, data, opts) {
  const name = template.replace(/\${(.*?)}/g, function (match, field) {
    let value = getDataSafe(data, field.trim())
    if (value != null && typeof value === 'object') {
      value = JSON.stringify(value, null, opts.spaces || 2)
    }
    return value != null ? value : match
  }).replace(/[_-]{2,}/g, '')
  return name
}

const numberRegex = /^\d+(?:\.\d*)?$/
const boolRegex = /^(?:false|true)$/i
const nullRegex = /^null$/
const undefinedRegex = /^undefined$/
const jsonRegex = /^{(.|\n)*}$/

function inferTypes(node) {
  let type = typeof node
  if (Array.isArray(node)) {
    for (let i = 0; i < node.length; i++) {
      node[i] = inferTypes(node[i])
    }
  } else if (type === 'object' && node !== null) {
    Object.keys(node).map(key => {
      node[key] = inferTypes(node[key])
    })
  } else if (type === 'string') {
    if (numberRegex.test(node)) {
      return parseFloat(node)
    } else if (boolRegex.test(node)) {
      return node.toLowerCase() === 'true'
    } else if (nullRegex.test(node)) {
      return null
    } else if (undefinedRegex.test(node)) {
      return undefined
    } else if (jsonRegex.test(node)) {
      return JSON.parse(node)
    }
  }

  return node
}

function getConfigFullPath(serverless, file) {
  if (file) {
    file = path.resolve(process.cwd(), file)
  } else if (serverless.service.custom.leo && serverless.service.custom.leo.configurationPath) {
    file = path.resolve(serverless.serviceDir, serverless.service.custom.leo.configurationPath)
  } else {
    file = path.resolve(process.cwd(), './project-config.def.json')
  }
  return file
}

// function getConfigReferences2(config, i = 0) {
//   let lookups = {}
//   let env = {}
//   let response = {
//     lookups, env, index: i
//   }
//   Object.entries(config).forEach(([key, value]) => {
//     if (value != null && typeof value === 'object' &&
//       value.service != null && value.key != null && value.type != null) {
//       let index = ++response.index
//       // todo: fix key for secrets
//       env[`RS_${value.service}:${value.key}`] = 'RS' + index
//       let v
//       switch (value.service) {
//         case 'cf': v = {
//           'Fn::ImportValue': {
//             'Fn::Sub': value.key
//           }
//         }; break
//         case 'ssm': v = `{{ssm:${value.key}}}`; break
//         case 'secret': v = 'true'; break
//         case 'stack': v = {
//           'Ref': value.key
//         }; break
//       }
//       lookups['RS' + index] = v
//     } else if (value != null && typeof value === 'object') {
//       let r = getConfigReferences(value, response.index)
//       Object.assign(lookups, r.lookups)
//       Object.assign(env, r.env)
//       response.index = r.index
//     }
//   })

//   return response
// }

function getConfigReferences(config, useSecretsManager, lookups = [], permissions = new Set()) {
  let output = {}
  Object.entries(config).forEach(([key, value]) => {
    if (value != null && typeof value === 'object' &&
      value.service != null && value.key != null && value.type != null) {
      value.key = value.key.replace(/\$\{region\}/gi, '${AWS::Region}')
      let v
      switch (value.service) {
        case 'cf': v = {
          'Fn::ImportValue': {
            'Fn::Sub': value.key
          }
        }; break
        case 'ssm': v = { 'Fn::Sub': `{{resolve:ssm:${value.key}}}` }; break
        case 'secret':
          if (!useSecretsManager || (value.options && value.options.resolve === 'deploy')) {
            let parts = value.key.split('.')
            parts.splice(1, 0, 'SecretString')
            v = { 'Fn::Sub': `{{resolve:secretsmanager:${parts.join(':')}}}` }
          } else {
            v = { 'Fn::Sub': `secret::${value.key}::${value.type}` }
            let secretKey = value.key.split('.')[0]
            permissions.add(`arn:aws:secretsmanager:*:\$\{AWS::AccountId\}:secret:${secretKey}-*`)
          }
          break
        case 'stack': v = {
          'Ref': value.key
        }; break
      }
      output[key] = `\${RSF${lookups.length}}`
      lookups.push(v)
    } else if (value != null && typeof value === 'object') {
      let r = getConfigReferences(value, useSecretsManager, lookups, permissions)
      output[key] = r.output
    } else {
      output[key] = value
    }
  })

  return {
    output,
    lookups: lookups.reduce((all, one, index) => {
      all[`RSF${index}`] = one
      return all
    }, {}),
    permissions
  }
}

function getConfigEnv(serverless, file, config) {
  const stage = serverless.service.provider.stage
  const custom = serverless.service.custom[stage] ? serverless.service.custom[stage] : serverless.service.custom
  const leoStack = custom.leoStack || serverless.service.custom.leoStack
  const useSecretsManager = serverless.service.custom.leo.rsfConfigResolutionType === 'secretsmanager' || serverless.service.custom.leo.rsfConfigResolutionType == null
  // let lookups1 = {
  //   'RS1': {
  //     'Fn::ImportValue': {
  //       'Fn::Sub': 'ProdAuth-LeoAuth'
  //     }
  //   },
  //   'RS2': {
  //     'Ref': 'BotRole'
  //   },
  //   'RS3': 'us-east-1:220162591379',
  //   'RS4': 'us-east-1:220162591379'

  //   // 'RS3': '{{resolve:secretsmanager:arn:aws:secretsmanager:us-east-1:220162591379:secret:test_redshift_dw_read_only-VhLIcT:SecretString}}',
  //   // 'RS4': '{{resolve:secretsmanager:arn:aws:secretsmanager:us-east-1:220162591379:secret:staging_redshift_dw_read_only-OapYum:SecretString}}'
  //   // 'RS3': '{{resolve:secretsmanager:${MyStage1}_redshift_dw_read_only:SecretString}}',
  //   // 'RS4': '{{resolve:secretsmanager:${MyStage2}_redshift_dw_read_only:SecretString}}'
  // }

  // let env1 = {
  //   STAGE: '${Stage}', // Serverless Stage
  //   MY_STAGE_1: '${MyStage1}', // Pulled from
  //   MY_STAGE_2: '${MyStage2}',
  //   'RS_cf::item-${MyStage1}-elasticendpoint': '${RS1}',
  //   'RS_stack::some-stack-variable-of-my-own': '${RS2}',
  //   // "RS_secret::test_redshift_dw_read_only.password" = "password_12345";
  //   // "RS_secret::test_redshift_dw_read_only" = JSON.stringify({ username: "my_username", password: "password_1234", port: 54390 });

  //   'RS_secret::${MyStage1}_redshift_dw_read_only': '${RS3}',
  //   // JSON.stringify({
  //   //   'username': 'dw_read_user',
  //   //   'password': '1234',
  //   //   'engine': 'redshift',
  //   //   'host': 'testdw-redshift-t31bfkdfcz5x.cozies5zhqyd.us-east-1.redshift.amazonaws.com',
  //   //   'port': 5439,
  //   //   'dbClusterIdentifier': 'testdw-redshift-t31bfkdfcz5x'
  //   // }),
  //   // "RS_secret::${stage}_redshift_dw_read_only": "true"

  //   'RS_secret::${MyStage2}_redshift_dw_read_only': '${RS4}'
  //   // JSON.stringify({
  //   //   'username': 'dw_read_user-dev',
  //   //   'password': '9876-dev',
  //   //   'engine': 'redshift-dev',
  //   //   'host': 'testdw-redshift-t31bfkdfcz5x.cozies5zhqyd.us-east-1.redshift.amazonaws.com-dev',
  //   //   'port': 1234,
  //   //   'dbClusterIdentifier': 'testdw-redshift-t31bfkdfcz5x-dev'
  //   // })
  // }

  let { output, lookups, permissions } = getConfigReferences(config, useSecretsManager)

  let params = {};

  // Find Stack Parameters
  (JSON.stringify(lookups).match(/\$\{(.*?)\}/g) || []).forEach((a) => {
    let key = a.replace(/^\$\{(.*)\}$/, '$1')
    if (!(key in params)) {
      let value = serverless.pluginManager.cliOptions[key]

      if (value == null) {
        if (key.match(/^stage$/i)) {
          value = serverless.service.provider.stage

          // Proper Case if needed
          if (key[0] === key[0].toUpperCase()) {
            value = toProperCase(value)
          }
        } else if (key.match(/^AWS::.*$/i)) {
          // AWS var
          return
        } else if (serverless.service.resources.Resources[key] || serverless.service.resources.Parameters[key]) {
          // Stack var
          return
        }
      }

      params[key] = {
        Type: 'String',
        MinLength: 1,
        Description: key,
        Value: value
      }
    }
  })
  // let params = {
  //   stage: {
  //     Type: 'String',
  //     MinLength: 1,
  //     Description: 'Stage',
  //     Value: serverless.service.provider.stage
  //   },
  //   MyStage1: {
  //     Type: 'String',
  //     MinLength: 1,
  //     Description: 'Custom Stage',
  //     Value: serverless.pluginManager.cliOptions.MyStage1
  //   },
  //   MyStage2: {
  //     Type: 'String',
  //     MinLength: 1,
  //     Description: 'Custom Stage',
  //     Value: serverless.pluginManager.cliOptions.MyStage2
  //   }
  // }

  // Add permissions to lambda roles to read secrets
  const allFunctions = serverless.service.getAllFunctions()
  const roles = Object.keys(allFunctions.reduce((roles, functName) => {
    roles[serverless.service.getFunction(functName).role] = true
    return roles
  }, {}))

  let secretsPermissions = [].concat(Array.from(permissions).map(p => ({ 'Fn::Sub': p })))
  if (useSecretsManager) {
    secretsPermissions = secretsPermissions.concat({
      'Fn::Sub': 'arn:aws:secretsmanager:*:${AWS::AccountId}:secret:rsf-config-${AWS::StackName}-${AWS::Region}-*'
    }, {
      'Fn::Sub': `arn:aws:secretsmanager:\${AWS::Region}:\${AWS::AccountId}:secret:rstreams-${leoStack}-*`
    })
  }

  roles.forEach(roleName => {
    let role = serverless.service.resources.Resources[roleName]

    if (role) {
      role.Properties.ManagedPolicyArns = (role.Properties.ManagedPolicyArns || []).concat({
        'Fn::ImportValue': {
          'Fn::Sub': `${leoStack}-Policy`
        }
      })
      if (secretsPermissions.length > 0) {
        role.Properties.Policies = (role.Properties.Policies || []).concat({
          PolicyName: 'RSFSecretAccess',
          PolicyDocument: {
            Version: '2012-10-17',
            Statement: [
              {
                Effect: 'Allow',
                Action: 'secretsmanager:GetSecretValue',
                Resource: secretsPermissions
              }
            ]
          }
        })
      }
    }
  })

  let map = {
    RSFReplicaMap: {
      'us-east-2': ['us-east-1'],
      'us-east-1': ['us-west-2'],
      'us-west-1': ['us-east-1'],
      'us-west-2': ['us-east-1'],
      'af-south-1': ['us-east-1'],
      'ap-east-1': ['ap-south-1'],
      'ap-south-1': ['ap-east-1'],
      'ap-northeast-3': ['ap-east-1'],
      'ap-northeast-2': ['ap-east-1'],
      'ap-southeast-1': ['ap-east-1'],
      'ap-southeast-2': ['ap-east-1'],
      'ap-northeast-1': ['ap-east-1'],
      'ca-central-1': ['us-east-1'],
      'eu-central-1': ['eu-west-1'],
      'eu-west-1': ['eu-central-1'],
      'eu-west-2': ['eu-central-1'],
      'eu-south-1': ['eu-central-1'],
      'eu-west-3': ['eu-central-1'],
      'eu-north-1': ['eu-central-1'],
      'me-south-1': ['us-east-1'],
      'sa-east-1': ['us-east-1']
    }
  }
  let replicaRegions = ['us-east-1']
  let rsfConfigName = {
    'Fn::Sub': 'rsf-config-${AWS::StackName}-${AWS::Region}'
  }
  return {
    env: Object.assign({
      RSF_CONFIG: useSecretsManager ? rsfConfigName : {
        'Fn::Sub': [
          JSON.stringify(output), lookups
        ]
      }
    }, useSecretsManager ? {
      // Add RStreams config resource
      RSTREAMS_CONFIG_SECRET: {
        'Fn::Sub': `rstreams-${leoStack}`
      }
    } : {
      RSTREAMS_CONFIG: {
        'Fn::Sub': [JSON.stringify({
          'region': '${Region}',
          'kinesis': '${LeoKinesisStream}',
          's3': '${LeoS3}',
          'firehose': '${LeoFirehoseStream}',
          'resources': {
            'LeoStream': '${LeoStream}',
            'LeoCron': '${LeoCron}',
            'LeoEvent': '${LeoEvent}',
            'LeoSettings': '${LeoSettings}',
            'LeoSystem': '${LeoSystem}',
            'LeoS3': '${LeoS3}',
            'LeoKinesisStream': '${LeoKinesisStream}',
            'LeoFirehoseStream': '${LeoFirehoseStream}',
            'Region': '${Region}'
          }
        }), {
          'LeoStream': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-LeoStream`
            }
          },
          'LeoCron': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-LeoCron`
            }
          },
          'LeoEvent': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-LeoEvent`
            }
          },
          'LeoSettings': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-LeoSettings`
            }
          },
          'LeoSystem': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-LeoSystem`
            }
          },
          'LeoS3': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-LeoS3`
            }
          },
          'LeoKinesisStream': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-LeoKinesisStream`
            }
          },
          'LeoFirehoseStream': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-LeoFirehoseStream`
            }
          },
          'Region': {
            'Fn::ImportValue': {
              'Fn::Sub': `${leoStack}-Region`
            }
          }
        }]
      }
    }),

    params: params,
    resources: useSecretsManager ? {
      RSFConfig: {
        Type: 'AWS::SecretsManager::Secret',
        Properties: {
          Description: {
            'Fn::Sub': 'Secrets for Serverless Stack ${AWS::StackName} in ${AWS::Region}'
          },
          Name: rsfConfigName,
          SecretString: {
            'Fn::Sub': [
              JSON.stringify(output, null, 2), lookups
            ]
          },
          ReplicaRegions: replicaRegions.map(region => ({
            Region: region
          })),
          Tags: [{
            Key: 'service',
            Value: serverless.service.service
          }]
        }
      }
    } : {}
  }
}
function populateEnvFromConfig(serverless, file, config) {
  let { params, env, resources } = getConfigEnv(serverless, file, config)
  if (env) {
    serverless.service.provider.environment = Object.assign(env, serverless.service.provider.environment)
  }
  if (resources) {
    serverless.service.resources.Resources = Object.assign(resources, serverless.service.resources.Resources)
  }
  if (params) {
    serverless.service.provider.stackParameters = []
      .concat(serverless.service.provider.stackParameters)
      .concat(Object.entries(params)
        .filter(([, value]) => value.Value != null)
        .map(([key, value]) => {
          return {
            ParameterKey: key,
            ParameterValue: value.Value
          }
        }))
    serverless.service.resources.Parameters = Object.assign(
      Object.entries(params).reduce((all, [key, value]) => {
        let v = {
          ...value
        }
        delete v.Value
        all[key] = v
        return all
      }, {}), serverless.service.resources.Parameters)
  }
}
module.exports = {
  generateConfig,
  getConfigFullPath,
  getConfigEnv,
  populateEnvFromConfig
}
